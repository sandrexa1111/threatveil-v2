You are a senior full-stack engineer and AI security expert. Generate a complete, runnable Phase-1 of ThreatVeilAI using only free-tier-friendly services. No mock data ‚Äî use passive/public sources only. Deliver production-grade scaffolding and code that runs locally and on Vercel (frontend) + Render/Railway (backend).

üéØ Mission (why)

Give SMBs a one-input ‚Üí one clear answer AI-assisted security check. We scan public metadata, compute a deterministic risk score, and produce a concise Gemini summary + downloadable PDF. Passive only: 1 GET to root, DNS/TLS/HTTP headers/CT logs, Vulners CVEs by tech token, optional GitHub code search.

‚úÖ Scope (Phase-1)  

Input: { domain, github_org? }

Output: JSON with { risk_score, categories, signals, summary, breach_likelihood_30d/90d } + PDF report

Frontend: single page with scan form ‚Üí result card ‚Üí PDF button

Backend: FastAPI with /api/v1/scan/vendor, /api/v1/report/generate, /api/ping

Datastore: SQLite local, optional Postgres (Supabase)

AI: Gemini 1.5 Pro with deterministic fallback
 
Scheduling: document CRON call to /api/v1/agent/rescan?token=‚Ä¶

üß± Tech Stack (free-tier)

Frontend: Next.js 14 (App Router) + TypeScript + TailwindCSS + shadcn/ui + TanStack Query (React Query) + Zod

Backend: FastAPI (Python 3.11), httpx (async), SQLAlchemy, ReportLab

DB: SQLite file; DATABASE_URL switches to Postgres (Supabase)

AI: Gemini 1.5 Pro (GEMINI_API_KEY); fallback summary

Intel: Vulners, crt.sh, DNS, TLS/HTTP headers, optional GitHub search

Deploy: Vercel (frontend) + Render/Railway (backend)

Lint/Format: ESLint + Prettier

License: MIT-compatible libs only

üîë Environment Variables (you already set them; keep this in repo as .env.example)
NEXT_PUBLIC_APP_NAME=ThreatVeilAI
NEXT_PUBLIC_API_BASE=http://127.0.0.1:8000

ALLOWED_ORIGINS=http://localhost:3000
USER_AGENT=ThreatVeilScanner/0.1 (+https://threatveil.com)

DATABASE_URL=
SQLITE_PATH=./backend/app.db

GEMINI_API_KEY=
GITHUB_TOKEN=
VULNERS_API_KEY=
OTX_API_KEY=
LAKERA_API_KEY=

JWT_SECRET=change_me
RATE_LIMIT_PER_MINUTE=60

SLACK_WEBHOOK_URL=
RESEND_API_KEY=
PORT=8000
ENVIRONMENT=development
LOG_LEVEL=info

üóÇÔ∏è Repository Layout (generate these files with code)
threatveil/
  README.md
  .gitignore
  .env.example
  package.json                 # workspace root with scripts to run both apps (optional)

  frontend/
    next.config.mjs
    package.json
    tsconfig.json
    postcss.config.js
    tailwind.config.ts
    src/
      app/
        layout.tsx
        globals.css
        page.tsx               # Scan page (single page app)
        (scan)/loading.tsx     # Suspense loader (optional)
      components/
        Header.tsx
        Footer.tsx
        DomainForm.tsx         # form with zod validation
        RiskCard.tsx           # shows score, categories, summary
        ScoreBadge.tsx         # color-coded score
        CategoryBars.tsx       # small bar chart per category
        SignalsTable.tsx       # list of signals with severity chips
        DownloadPdfButton.tsx  # calls /report/generate
        LoadingSpinner.tsx
        Toaster.tsx            # shadcn/ui toast provider
      lib/
        api.ts                 # fetchers (scan, report, ping)
        queryClient.ts         # TanStack Query client
        types.ts               # shared TS types matching backend
        format.ts              # number/date/percent helpers
      styles/
        shadcn.css             # (generated by shadcn)
      hooks/
        useScanMutation.ts     # encapsulate scan call + states
    public/
      favicon.ico
      og.png

  backend/
    main.py
    db.py
    models.py
    schemas.py
    security.py
    requirements.txt
    routes/
      ping.py
      scan.py
      report.py
      chat.py
      agent.py
    services/
      dns_service.py
      http_service.py
      tls_service.py
      ctlog_service.py
      cve_service.py          # Vulners client
      github_service.py
      llm_service.py          # Gemini + fallback
      ml_service.py           # heuristic probabilities
      report_service.py       # ReportLab PDF
    utils/
      scoring.py
      normalize.py
      time.py
    tests/
      test_scoring.py
      test_scan_smoke.py      # safe, limited smoke test
  infra/
    render-backend.yaml
    railway.json
    vercel.json

üéõÔ∏è Frontend ‚Äî exact requirements & responsibilities
App Router & Layout

src/app/layout.tsx

Global providers: QueryClientProvider, Toaster, <html lang="en">, metadata

Import globals.css and shadcn styles

src/app/page.tsx

Renders <Header/>, <DomainForm/>, conditional <RiskCard/>, <Footer/>

Components (props & behavior)

DomainForm.tsx

Props: none

Uses: react-hook-form + @hookform/resolvers/zod

Zod schema: { domain: string (FQDN), github_org?: string }

On submit ‚Üí calls useScanMutation ‚Üí shows loading spinner

RiskCard.tsx

Props: scan: ScanResult

Sections: <ScoreBadge score={‚Ä¶}/>; <CategoryBars categories={‚Ä¶}/>; <SignalsTable signals={‚Ä¶}/>; Summary box; <DownloadPdfButton scan={scan}/>

ScoreBadge.tsx

Props: score: number

Color rules: <=30 green, 31‚Äì70 amber, >70 red

CategoryBars.tsx

Props: { network: number; software: number; data_exposure: number; ai_integration: number }

Displays simple Tailwind bars (no chart lib)

SignalsTable.tsx

Props: signals: Signal[]

Columns: Type, Detail, Severity (chip), Source (icon), Evidence link (if any)

DownloadPdfButton.tsx

Props: scan: ScanResult

POST /api/v1/report/generate with scan ‚Üí download blob as threatveil-report.pdf

Header.tsx/Footer.tsx

Static branding + legal copy (‚ÄúPassive OSINT only‚Äù)

Toaster.tsx, LoadingSpinner.tsx

Use shadcn/ui primitives

lib & hooks

lib/types.ts

export type CategoryScores = { network:number; software:number; data_exposure:number; ai_integration:number };
export type Evidence = { source:string; observed_at:string; url?:string; raw?:Record<string,unknown> };
export type Signal = { id:string; type:string; detail:string; severity:'low'|'medium'|'high'; category:keyof CategoryScores; evidence:Evidence };
export type ScanResult = {
  id:string; domain:string; risk_score:number; risk_likelihood_30d:number; risk_likelihood_90d:number;
  categories:CategoryScores; signals:Signal[]; summary:string; created_at:string;
};


lib/api.ts

scanVendor(payload:{domain:string; github_org?:string}) => Promise<ScanResult>

generatePdf(scan:ScanResult) => Promise<Blob>

ping() => Promise<{ok:true}>

Base URL from process.env.NEXT_PUBLIC_API_BASE

lib/queryClient.ts

Exports a configured TanStack Query client (retry 0 for POSTs)

hooks/useScanMutation.ts

Wraps scanVendor in useMutation, exposes { mutate, isLoading, data, error }

Styling & UI libs

Tailwind with tailwind.config.ts (content globs for app/**/*, components/**/*, lib/**/*)

shadcn/ui setup (generate button, input, card, badge, toast)

Validation

Zod schema for domain (/^[a-z0-9.-]+\.[a-z]{2,}$/i) & org (optional slug)

Build scripts (frontend package.json)
{
  "scripts": {
    "dev": "next dev -p 3000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.x",
    "react": "18.x",
    "react-dom": "18.x",
    "zod": "^3",
    "@tanstack/react-query": "^5",
    "react-hook-form": "^7",
    "@hookform/resolvers": "^3",
    "clsx": "^2",
    "tailwindcss": "^3",
    "postcss": "^8",
    "autoprefixer": "^10",
    "lucide-react": "^0.4",
    "sonner": "^1",                 // or shadcn toast wrapper
    "tailwind-merge": "^2"
  },
  "devDependencies": {
    "typescript": "^5",
    "eslint": "^9",
    "eslint-config-next": "^14"
  }
}

üåê Passive Data Sources (backend must implement)

DNS (dnspython): A/AAAA/MX/TXT + _dmarc.domain TXT

TLS: issuer, SANs, notAfter ‚Üí days_to_expiry

HTTP root GET: check HSTS, CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy, http‚Üíhttps redirect

CT logs: https://crt.sh/?q=<domain>&output=json (dedupe; count entries)

Vulners: POST /api/v3/search/lucene/ ‚Üí map CVSS to severity

GitHub (optional): /search/code?q=org:ORG+pattern (PAT read-only)

Gemini: models/gemini-1.5-pro:generateContent summary ‚â§120 words
All external calls: timeouts (8‚Äì20s), retries with jitter (max 3), DB cache (24h)

üßÆ Risk Model (deterministic)

Severity ‚Üí points: low=5, medium=15, high=30

Category weights: network 0.4, software 0.35, data_exposure 0.2, ai_integration 0.05

Examples: Missing HSTS (software high); No http‚Üíhttps redirect (network high); TLS <30d (network high); Missing CSP (software high); API key in GitHub (ai high)

üîå API Contract (backend)

GET /api/ping ‚Üí { ok: true }

POST /api/v1/scan/vendor
In: { "domain": "example.com", "github_org": "acme" | null }
Out: ScanResult (see TS type above)

POST /api/v1/report/generate
In: { "scan": <ScanResult> } ‚Üí Out: application/pdf bytes

POST /api/v1/chat (simple Gemini Q&A over a safe system prompt)

POST /api/v1/agent/rescan?token=<jwt> (document CRON; return {ok:true} for now)

üß∞ Backend Implementation Rules

FastAPI app with CORS from ALLOWED_ORIGINS

Parallelize DNS/TLS/HTTP/CT/Vulners via asyncio.gather

SQLAlchemy model scans + cache

scoring.py returns { risk_score, categories }

ml_service.py returns { risk_likelihood_30d, risk_likelihood_90d } (heuristic)

llm_service.py calls Gemini with system prompt; fallback template if key missing

report_service.py builds 1‚Äì2 page PDF (title, score, categories, top 5 signals, summary, timestamp)

security.py: basic JWT for /agent/rescan

Rate-limit per IP from RATE_LIMIT_PER_MINUTE

Any failure ‚Üí partial results + warning signal (never crash the scan)

üß™ Acceptance Criteria

/api/ping ‚Üí {ok:true}

Real domain scan returns non-empty signals[], integer risk_score ‚àà [0..100], risk_likelihood_* ‚àà [0..1], persists to DB

PDF endpoint returns non-zero bytes

Frontend flow: user submits domain ‚Üí shows RiskCard ‚Üí can download PDF

With no Gemini key, fallback summary is used, request does not fail

Exceeding rate limit returns HTTP 429

üßπ Quality & Security

Strict types (TS + Python); docstrings & inline comments

httpx timeouts (8‚Äì20s), exp backoff with jitter

DB caching for Vulners, CT logs, Gemini summaries

Passive-only policy enforced in code; user-agent set

No secrets in frontend; keys only backend

MIT-compatible dependencies

README includes full local run and deploy steps (Vercel, Render/Railway)

üß© Output Expectations for Codex

Generate all files above with runnable code.

Populate components with real logic (no mocks).

Wire frontend to backend using NEXT_PUBLIC_API_BASE.

Include Tailwind + shadcn setup (ready to run).

Print final local commands and deploy steps in README.

üöÄ Begin Now

Generate the full codebase per this spec. Keep it passive, fast, and explainable. End with the exact commands to:

Install & run backend on port 8000

Install & run frontend on port 3000

Deploy backend to Render/Railway and frontend to Vercel
# ThreatVeil – Full System Context (Phase 1 + Phase 1.1)
# Purpose:
# This file provides the complete, authoritative, non-ambiguous context for the ThreatVeil codebase.
# It defines: goals, architecture, constraints, API contracts, data models, and safety rules.
# Coding assistants MUST NOT hallucinate new fields, tables, services, or features not stated here.

================================================================================
1. PRODUCT OVERVIEW
================================================================================

ThreatVeil is a dual-layer cybersecurity + AI-security platform designed for SMBs.

The platform performs:

1) Passive Cyber Risk Scan (Phase 1)
   - DNS, TLS, HTTP headers, CT logs, Vulners CVE lookup
   - Deterministic risk scoring (0–100)
   - Gemini-powered summary (fallback deterministic text)
   - PDF report generation
   - No active scanning, crawling, or intrusive tests

2) AI Usage & AI Security Detection (Phase 1.1)
   - Detects AI libraries, agent frameworks, AI config files, LLM orchestration
   - Detects accidental AI API key leaks (OpenAI, Gemini, Anthropic, HuggingFace, etc.)
   - Computes AI Risk Score (0–100)
   - Generates AI-focused summary (Gemini or fallback)
   - Stores ScanAI record linked to Scan

These two scans together form ThreatVeil's **Horizon** architecture.

Target Users:
- SMBs with no security team
- AI-driven startups
- Developers / agencies
- Companies unaware of AI usage inside their repos ("Shadow AI")

================================================================================
2. HIGH-LEVEL SYSTEM ARCHITECTURE
================================================================================

Frontend (Vercel, free tier)
- Next.js 14 + TypeScript + Tailwind + shadcn/ui
- Single page for scanning
- RiskCard + AIRiskPanel components
- PDF download

Backend (Render/Railway free tier)
- FastAPI (Python 3.11)
- SQLite or Postgres via Supabase (if DATABASE_URL is set)
- Passive Services:
    dns_service.py
    http_service.py
    tls_service.py
    ctlog_service.py
    cve_service.py  (Vulners)
- AI Services:
    github_ai_service.py
    ai_scoring.py
    ai_summary_service.py
    ai_scan_service.py
- Report:
    report_service.py (ReportLab)
- Utility:
    scoring.py     (cyber risk deterministic scoring)
    normalize.py   (domain normalization)
    cache_service.py
    logging_config.py
    security.py (JWT + rate limiting)

Database:
- scans table
- scan_ai table
- cache table (for CT, Vulners, Gemini summaries)

External APIs (all passive & free-tier friendly):
- Vulners API (CVE)
- OTX API (optional)
- Gemini API (summaries only)
- GitHub public API (for AI detection)
- crt.sh for CT logs

================================================================================
3. DATA MODELS (Backend Source of Truth)
================================================================================

SCAN TABLE (scans):
- id (UUID)
- domain (text)
- github_org (text or null)
- risk_score (int 0–100)
- categories_json (JSON dict)
- signals_json (JSON array)
- summary (text)
- breach_probability_30d (float)
- breach_probability_90d (float)
- created_at (timestamp)
- raw_payload (JSON)

SCAN_AI TABLE (scan_ai):
- id (UUID)
- scan_id (UUID FK to scans.id)
- ai_score (0–100)
- ai_tools_detected (JSON array)
- ai_key_leaks (JSON array)
- ai_agents_detected (JSON array)
- ai_summary (text)
- created_at (timestamp)

NO OTHER FIELDS EXIST.  
Coding assistants must NOT create additional columns.

================================================================================
4. API CONTRACT (Backend)
================================================================================

### GET /api/ping
→ { "ok": true }

### POST /api/v1/scan/vendor
Input:
{
  "domain": "example.com",
  "github_org": "acme" | null
}

Output:
{
  "id": "uuid",
  "domain": "example.com",
  "risk_score": 37,
  "risk_likelihood_30d": 0.21,
  "risk_likelihood_90d": 0.33,
  "categories": {...},
  "signals": [...],
  "summary": "...",
  "created_at": "ISO8601"
}

### GET /api/v1/scan/{scan_id}/ai
Output:
{
  "scan_id": "uuid",
  "ai_score": 62,
  "ai_tools_detected": [...],
  "ai_agents_detected": [...],
  "ai_key_leaks": [...],
  "ai_summary": "...",
  "created_at": "ISO8601"
}
If ScanAI does not exist → HTTP 404

### POST /api/v1/report/generate
Input: { "scan": { full scan object } }
Output: PDF bytes

### POST /api/v1/chat
Input: { "message": "Explain HSTS" }
Output: { "reply": "..." }

================================================================================
5. PHASE 1: CYBER SCAN LOGIC
================================================================================

Deterministic Scoring:
- low=5, medium=15, high=30
- categories: network=0.4, software=0.35, data_exposure=0.2, ai_integration=0.05
- Score = weighted sum (0–100)

Signals:
- Missing HSTS
- Missing CSP
- TLS expiry <60 days
- No redirect to HTTPS
- CT log anomalies
- Vulners CVEs mapped to severity

Gemini Summary:
- <=120 words
- Non-technical
- 2–3 prioritized steps
- Fallback summary if Gemini fails

================================================================================
6. PHASE 1.1: AI DETECTION LOGIC
================================================================================

AI signals (github_ai_service.py):
- AI libraries:
    "openai", "anthropic", "langchain", "transformers",
    "huggingface", "vertexai", "google.generativeai", etc.

- AI agent frameworks:
    "crewai", "autogen", "langgraph"

- AI config files:
    *.prompt, *.ai, *.llm.yaml, ai-config.json

- AI API key leaks (regex):
    OPENAI_API_KEY
    GEMINI_API_KEY
    ANTHROPIC_API_KEY
    HUGGINGFACE_TOKEN
    FIREBASE_SERVICE_ACCOUNT

AI Scoring (ai_scoring.py):
- Libraries: +10 to +20
- Key leaks: +30 each, capped at 60
- Agents: +10 bonus
- Clamp 0–100

AI Summary:
- <=200 words
- Use Gemini if available
- Fallback deterministic summary

AI Scan Flow:
- Runs AFTER Scan is created
- Does not affect main scan results
- Errors must not break main scan

================================================================================
7. FRONTEND REQUIREMENTS
================================================================================

Components:
- RiskCard.tsx → cyber risk results  
- AIRiskPanel.tsx → AI risk results  
- DownloadPdfButton.tsx  
- PartialFailureBanner.tsx  
- ExplainResultButton.tsx  

UI/UX:
- Mobile-friendly
- Collapsible lists
- Score color coding (green/yellow/red)
- Plain-English description for SMBs
- Skeleton loading states
- Zero crashes on 404/500/null data

Error Handling:
- Missing ScanAI → "AI scan still running"
- No AI usage → "No AI detected"
- Fallback summary if ai_summary empty

================================================================================
8. SAFETY & CONSTRAINTS
================================================================================

ABSOLUTE RULES:
- **NO active scanning** (no port scans, no crawling)
- Only passive OSINT
- One GET to root page allowed
- No brute force DNS enumeration
- No accessing private GitHub data

AI RULES:
- Never fabricate fields or schema
- Never expose secrets to frontend
- Redact sensitive information

GENERAL:
- All external API failures must return partial results
- System must be operational even if Gemini is offline
- Logging must NOT leak API keys

================================================================================
9. PHASE ROADMAP (REFERENCE)
================================================================================

Phase 1 (completed):
- Cyber scan
- Gemini summary
- PDF reports

Phase 1.1 (completed):
- AI usage detection
- AI risk score
- AI summaries
- Frontend AI panel

Phase 1.2 (up next):
- AI supply-chain detection
- AI config leakage patterns
- Extended agent detection
- AI compliance indicators

================================================================================
END OF FILE – context.txt (ThreatVeil)
================================================================================
